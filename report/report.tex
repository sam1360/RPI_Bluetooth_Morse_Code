\documentclass[11pt]{article}

\usepackage{myreport}
\usepackage{csourcelst}

\begin{document}

\input{./cover.tex}

\section{Abstract}
\label{sec:abstract}


This project's goal was to develop a system to send messages to a Raspberry Pi~3 (RPi3) over Bluetooth via the mini uart and then translate them to Morse~code.
The translated message is then transmitted over the RPi3's~GPIO pins to produce a Morse~code message conforming to international Morse~code standards.
In order to accomplish this, two separate programs were created: one program to send the message (capable of being compiled and run on any device with BlueZ installed), and the other to receive the message on the RPi3.
Functions used for each discrete step were developed in separate files for reusability.
A program was also created to test the functionality of each step.
In the end, the system was fully-functional, able to deliver messages through Bluetooth and translate them into GPIO signals.


\section{Design Methodology}
\label{sec:design_methodology}


% TODO Design Methodology


\subsection{Hardware Configuration}
\label{sub:hardware_configuration}


Since realistically implementing a Bluetooth-based system on the RPi3 requires OS support, a direct interface to the hardware was not possible.
Attempts to do so violate the OS's security and segmentation protocols.
As such, in order to access the GPIO~pins for the duration of the lab, a separate, third-party library was necessary.
After some searching, the \href{http://wiringpi.com/}{wiringPi} library was discovered, providing precisely the interface to the GPIO that was needed.


The wiringPi library uses an alternative mapping of GPIO~pins.
For the purposes of this project, wiringPi pin~0 was chosen, which corresponds to GPIO~17 or physical pin~11 per the documentation \href{http://wiringpi.com/pins/}{found here}.
This means that, in order to wire an LED through the program, GPIO~17 must be wired to (alongside GPIO~15, acting as a ground).


To allow the receiving RPi3 to simultaneously use a serial UART connection and a Bluetooth connection, the Bluetooth must be rewired to the RPi3's mini-UART.
The method to accomplish this can vary by OS, but in this particular project (which uses Raspbian Jessie) that is accomplished by adding the line \code{dtoverlay=pi-miniuart-bt} to the config.txt file at the root directory.
In doing so, the RPi3 can be booted --- and the program therefore run --- via the UART console.


With the receiving RPi3 utilizing the previously determined parameters (output on GPIO~17, ground on GPIO~15, and UART connections), the hardware layout of the RPi3 will be the same as in Figure~\ref{fig:receive-gpio}.


% TODO Get image to put here
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{img/receive-gpio.png}
    \caption{The GPIO pin layout on the receiving RPi3.}
    \label{fig:receive-gpio}
\end{figure}


Note that the hardware of the sending device has not been discussed yet.
This is because only the receiving RPi3 has functionality tied directly to the Raspberry Pi hardware.
Theoretically, following complete development, the code to send messages \emph{to} the RPi3 can be compiled and run on any device that supports the BlueZ API.
Although, for the purposes of this lab, another RPi3 will be used as the sending device, the portability of the code means that the hardware configuration the code will run on is almost entirely unknowable beyond the presence of a few APIs.


\subsection{Morse Code \& Bluetooth Configuration}
\label{sub:morse_code_&_bluetooth_configuration}

Morse code was developed by Samuel F.B. Morse, Joseph Henry, and Alfred Vail developed morse code starting in 1836.
The first time Morse was used it worked by making indents on a strip of paper when the machine received electric current.
Morse had intended to only support numbers and then look each word up via a dictionary that mapped each number to a work.
Shortly after that was introduced however Alfred Vail expanded this to include both special characters and letters.
This made Morse code take off due to the fact that it was much easeir to translate.
Vail used frequency analysis to assign dots and dashes to the letters.

The Morse code specifies that a dot "." is a one unit, a dash "-" is a 3 units, in between each dot and dash is a 1 unit break, the space at the end of each letter is 3 units, and the break at the end of each word is 7 units.
The reason for specifying the time length as units is due to the fact that the breaks do no have and specified length, its relative to the speed at which the operator can send and receive messages.


The bluetooth connection is done using RFCOMM communication protocol.
RFCOMM ends up as a similar connection to that of a serial connection.
This made it easy to transmit and receive streams of data over the Raspberry Pi 3's mini UART.
The other reason for the selection of RFCOMM was the relative ease of use that the protocol provided, meaning that it didn't devour to much development time.
Within the receiving Raspberry Pi 3 bluetoothctl must turn discoverable on, so that the sending Pi can transmit data to it.
THe port that the pi recieves on is the first one of the current open connection.


% TODO MORSE CODE & Bluetooth Configuration
% The title of this section might change later


\subsection{Program Design}
\label{sub:program_design}



% TODO Program Design


\begin{algorithm}[ht]
    \begin{algorithmic}[l]
        \Procedure{blink\_signal\_from\_input}{char *buffer, Morse *codes}
        \State $n \gets$ \code{length(buffer)}
        \State $\code{converted} \gets$ \code{get\_codes\_from\_input( buffer, $n$, codes )}
        \For{$ i \gets 0 \text{ to } n$}
            \State $\text{count} \gets 0$
            \If{$ \code{converted[i].code} = 0 $}
                \State delay 4 ticks
                \State continue to next loop
            \EndIf
            \While{$ \code{converted[i].code} \brshift \text{count} \neq 1 $}
                \State $\text{count} \gets \text{count} + 1$
            \EndWhile
            \For{$ j \gets \text{count to } 0 $}
                \If{the jth bit of \code{converted[i].code} is 1}
                    \State blink on
                \Else
                    \State blink off
                \EndIf
                \State delay 1 tick
            \EndFor
            \State blink off
            \State delay 3 ticks
        \EndFor
        \EndProcedure
    \end{algorithmic}
    \caption{Pseudocode for converting the input to a signal through GPIO.}
    \label{alg:blink_signal_from_input}
\end{algorithm}


\section{Results and Analysis}
\label{sec:results_and_analysis}


% TODO Results & Analysis


\section{Conclusions}
\label{sec:conclusions}


% TODO Conclusions


\section{Source}
\label{sec:source}


\input{./source.tex}


\end{document}
