\documentclass[11pt]{article}

\usepackage{myreport}
\usepackage{csourcelst}

\begin{document}

\input{./cover.tex}

\section{Abstract}
\label{sec:abstract}


This project's goal was to develop a system to send messages to a Raspberry Pi~3 (RPi3) over Bluetooth via the mini uart and then translate them to Morse~code.
The translated message is then transmitted over the RPi3's~GPIO pins to produce a Morse~code message conforming to international Morse~code standards.
In order to accomplish this, two separate programs were created: one program to send the message (capable of being compiled and run on any device with BlueZ installed), and the other to receive the message on the RPi3.
Functions used for each discrete step were developed in separate files for reusability.
A program was also created to test the functionality of each step.
In the end, the system was fully-functional, able to deliver messages through Bluetooth and translate them into GPIO signals.


\section{Design Methodology}
\label{sec:design_methodology}


% TODO Design Methodology


\subsection{Hardware Configuration}
\label{sub:hardware_configuration}


Since realistically implementing a Bluetooth-based system on the RPi3 requires OS support, a direct interface to the hardware was not possible.
Attempts to do so violate the OS's security and segmentation protocols.
As such, in order to access the GPIO~pins for the duration of the lab, a separate, third-party library was necessary.
After some searching, the \href{http://wiringpi.com/}{wiringPi} library was discovered, providing precisely the interface to the GPIO that was needed.


The wiringPi library uses an alternative mapping of GPIO~pins.
For the purposes of this project, wiringPi pin~0 was chosen, which corresponds to GPIO~17 or physical pin~11 per the documentation \href{http://wiringpi.com/pins/}{found here}.
This means that, in order to wire an LED through the program, GPIO~17 must be wired to (alongside GPIO~15, acting as a ground).


To allow the receiving RPi3 to simultaneously use a serial UART connection and a Bluetooth connection, the Bluetooth must be rewired to the RPi3's mini-UART.
The method to accomplish this can vary by OS, but in this particular project (which uses Raspbian Jessie) that is accomplished by adding the line \code{dtoverlay=pi-miniuart-bt} to the config.txt file at the root directory.
In doing so, the RPi3 can be booted --- and the program therefore run --- via the UART console.


With the receiving RPi3 utilizing the previously determined parameters (output on GPIO~17, ground on GPIO~15, and UART connections), the hardware layout of the RPi3 will be the same as in Figure~\ref{fig:receive-gpio}.


% TODO Get image to put here
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{img/receive-gpio.png}
    \caption{The GPIO pin layout on the receiving RPi3.}
    \label{fig:receive-gpio}
\end{figure}


Note that the hardware of the sending device has not been discussed yet.
This is because only the receiving RPi3 has functionality tied directly to the Raspberry Pi hardware.
Theoretically, following complete development, the code to send messages \emph{to} the RPi3 can be compiled and run on any device that supports the BlueZ API.
Although, for the purposes of this lab, another RPi3 will be used as the sending device, the portability of the code means that the hardware configuration the code will run on is almost entirely unknowable beyond the presence of a few APIs.


\subsection{Morse Code \& Bluetooth Configuration}
\label{sub:morse_code_&_bluetooth_configuration}

Morse code was developed by Samuel F.B. Morse, Joseph Henry, and Alfred Vail developed morse code starting in 1836.
The first time Morse was used it worked by making indents on a strip of paper when the machine received electric current.
Morse had intended to only support numbers and then look each word up via a dictionary that mapped each number to a work.
Shortly after that was introduced however Alfred Vail expanded this to include both special characters and letters.
This made Morse code take off due to the fact that it was much easeir to translate.
Vail used frequency analysis to assign dots and dashes to the letters.

The Morse code specifies that a dot "." is a one unit, a dash "-" is a 3 units, in between each dot and dash is a 1 unit break, the space at the end of each letter is 3 units, and the break at the end of each word is 7 units.
The reason for specifying the time length as units is due to the fact that the breaks do no have and specified length, its relative to the speed at which the operator can send and receive messages.


The bluetooth connection is done using RFCOMM communication protocol.
RFCOMM ends up as a similar connection to that of a serial connection.
This made it easy to transmit and receive streams of data over the Raspberry Pi 3's mini UART.
The other reason for the selection of RFCOMM was the relative ease of use that the protocol provided, meaning that it didn't devour to much development time.
Within the receiving Raspberry Pi 3 bluetoothctl must turn discoverable on, so that the sending Pi can transmit data to it.
THe port that the pi recieves on is the first one of the current open connection.


% The title of this section might change later


\subsection{Program Design}
\label{sub:program_design}



% TODO Program Design

% VERY BASIC OUTLINE
% Talk about higher-level execution; execution of bt-send and bt-receive on different devices
% High-level UML Diagram (what the program looks like at a higher level)
% Discuss bt-send
%     RFCOMM connection establish
%     Receive and package user data
% Discuss bt-receive
%     RFCOMM connection establish
%     State Diagram (what we are trying to accomplish)
%     Describe Lookup Table system (create table then convert characters of input into array of references to table)
%     Describe mapping bits to ticks ON and OFF per Morse code spec in \ref{sub:morse_code_&_bluetooth_configuration}; refer to State Diagram
%     Algorithm sketch for blink_code
%     Algorithm for blink_code


As has been stated in Subsection~\ref{sub:hardware_configuration}, the system operates not in a single RPi3, but in two different devices.
One of these devices specifies a MAC address field, then attempts to connect to the given MAC address and, if successful, sends packets of user input to the connected device.
The other device (the receiving RPi3) accepts a connection with a sending device, takes and decodes packets of user input, and turns it into blinkable Morse~code.
It is natural to split up both subsystems, then, and compile them separately.
This separation is reflected in the higher-level UML diagram for the system in Figure~\ref{fig:bt-morse-uml}, which details the soft and physical architecture of the system.


\begin{figure}[ht]
    \centering
    \includegraphics{img/bt-morse-uml.png}
    \caption{The high-level UML diagram for the project.}
    \label{fig:bt-morse-uml}
\end{figure}


Through Figure~\ref{fig:bt-morse-uml}, it is clear that although the systems are intertwined in execution, they \emph{are} separate programs.


% Hmm, maybe put this in its own section?
The sending component can be handled by a \code{bt-send.c}.


\begin{figure}[ht]
    \centering
    \includegraphics{img/bt-morse-state-diagram.png}
    \caption{A state diagram for the program. Note the resemblance to the Morse code spec from Subsection~\ref{sub:morse_code_&_bluetooth_configuration}.}
    \label{fig:bt-morse-state-diagram}
\end{figure}


\begin{algorithm}[ht]
    \begin{algorithmic}[l]
        \Procedure{blink\_signal\_from\_input}{char *buffer, Morse *codes}
        \State $n \gets$ \code{length(buffer)}
        \State $\code{converted} \gets$ \code{get\_codes\_from\_input( buffer, $n$, codes )}
        \For{$ i \gets 0 \text{ to } n$}
            \State $\text{count} \gets 0$
            \If{$ \code{converted[i].code} = 0 $}
                \State delay 4 ticks
                \State continue to next loop
            \EndIf
            \While{$ \code{converted[i].code} \brshift \text{count} \neq 1 $}
                \State $\text{count} \gets \text{count} + 1$
            \EndWhile
            \For{$ j \gets \text{count to } 0 $}
                \If{the jth bit of \code{converted[i].code} is 1}
                    \State blink on
                \Else
                    \State blink off
                \EndIf
                \State delay 1 tick
            \EndFor
            \State blink off
            \State delay 3 ticks
        \EndFor
        \EndProcedure
    \end{algorithmic}
    \caption{Pseudocode for converting the input to a signal through GPIO.}
    \label{alg:blink_signal_from_input}
\end{algorithm}


\section{Results and Analysis}
\label{sec:results_and_analysis}

\begin{figure}[ht]
    \centering
    \includegraphics{img/program_output.png}
    \caption{The output from the two terminals, on the left is transmit and on the right is receive.}
    \label{fig:program_output}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics{img/morse.svg}
    \caption{An image displaying the conversion from ASCII to dots and dashes.}
    \label{fig:program_output}
\end{figure}

As displayed in Figure~\ref(fig:program_output), the program ran as specified.
The program was required to take input from a user on and then proceed to transmit it over bluetooth to the receiving Raspberry Pi.
From there the program needs to convert the ASCII text to dots and dashes, which is shown by the output.
The input and the received value was hey whats up.
The program translated the code to "**** * -*--   *-- **** *- - ***   **- *--*" as shown in the Figure~\ref(fig:program_output).
Using the International Morse code Figure~\ref(fig:international_morse_code) it shows that H=****, E=* Y=-*--, W=*--, H=****, A=*-, T=-, S=***, U=**-, and P=*--*.
This shows that the code is valid for converting characters to morse.
The UART blink in operation is shown in Figure~\ref(fig:uart_blink), as well as the correct pinout to use when running the application.

\section{Conclusions}
\label{sec:conclusions}

The objective to connect two Raspberry Pi's together and have them communicate via bluetooth was successful.
On top of that it was successful in converting from ASCII to morse code and then blinking it by using a GPIO pin to switch the output from low to high.
There are numerous applications for bluetooth espicially with the prevalence of IoT's connected devices.
With bluetooth it allows people to connect more and more devices to either their phone or computer, and get data or control different parts of a system remotely.
This is an industry that is only just starting to take off, things like watches are becoming more and more connected due to the use of bluetooth connectivity.
The main issues that were encountered during the creation of this project included getting bluetooth working, the initial configuration of the Raspberry Pis, and conflicting schedules.
Bluetooth was solved by using resources online as well as just struggling through until the Pis connected to one another.
The configuration was solved in a similar way, mostly trial and web resources to get it running.
Regarding conflicting schedules, this was resolved by a really long weeked when we both finally had time to get together and work on the code.
If we were to do it over again, we would either try to find more time to meet, or pass off the Raspberry Pis to one another when one of us had free time to work on it.


\section{Source}
\label{sec:source}


\input{./source.tex}


\end{document}
